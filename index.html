<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>æœºå™¨äººå¯¼èˆªçŠ¶æ€ç›‘æ§</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    .header {
      background-color: #2c3e50;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    .panel {
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .full-width {
      grid-column: 1 / -1;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .status-idle { background-color: #95a5a6; }
    .status-going { background-color: #f39c12; }
    .status-paused { background-color: #e67e22; }
    .status-succeeded { background-color: #27ae60; }
    .status-failed { background-color: #e74c3c; }
    .map-container {
      border: 2px solid #34495e;
      border-radius: 8px;
      overflow: hidden;
    }
    canvas {
      display: block;
      cursor: crosshair;
    }
    .status-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    .status-item {
      padding: 10px;
      background-color: #ecf0f1;
      border-radius: 4px;
      border-left: 4px solid #3498db;
    }
    .status-item h4 {
      margin: 0 0 5px 0;
      color: #2c3e50;
    }
    .status-item .value {
      font-size: 18px;
      font-weight: bold;
      color: #3498db;
    }
    .navigation-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    .history-log {
      max-height: 300px;
      overflow-y: auto;
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 2px 0;
    }
    .log-timestamp {
      color: #95a5a6;
      margin-right: 10px;
    }
    .input-group {
      margin: 10px 0;
      padding: 15px;
      background-color: #ecf0f1;
      border-radius: 4px;
    }
    .input-group label {
      display: inline-block;
      width: 80px;
      margin-right: 10px;
      font-weight: bold;
    }
    .input-group input {
      padding: 8px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      margin-right: 10px;
      width: 100px;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #ecf0f1;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background-color: #3498db;
      transition: width 0.3s ease;
    }
    .alert {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    .alert-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .alert-warning {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    .alert-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ¤– æœºå™¨äººå¯¼èˆªçŠ¶æ€ç›‘æ§ç³»ç»Ÿ</h1>
    <p>å®æ—¶ç›‘æ§æœºå™¨äººå¯¼èˆªçŠ¶æ€ã€ä½ç½®ä¿¡æ¯å’Œä»»åŠ¡æ‰§è¡Œæƒ…å†µ</p>
  </div>

  <div class="container">
    <!-- å¯¼èˆªçŠ¶æ€é¢æ¿ -->
    <div class="panel">
      <h3>ğŸ§­ å¯¼èˆªçŠ¶æ€</h3>
      <div class="status-grid">
        <div class="status-item">
          <h4>å½“å‰çŠ¶æ€</h4>
          <div class="value">
            <span class="status-indicator status-idle" id="statusIndicator"></span>
            <span id="navigationStatus">IDLE</span>
          </div>
        </div>
        <div class="status-item">
          <h4>ç”µæ± ç”µé‡</h4>
          <div class="value" id="batteryLevel">85%</div>
          <div class="progress-bar">
            <div class="progress-fill" id="batteryProgress" style="width: 85%"></div>
          </div>
        </div>
        <div class="status-item">
          <h4>Xåæ ‡</h4>
          <div class="value" id="positionX">0.00</div>
        </div>
        <div class="status-item">
          <h4>Yåæ ‡</h4>
          <div class="value" id="positionY">0.00</div>
        </div>
        <div class="status-item">
          <h4>æœå‘è§’åº¦</h4>
          <div class="value" id="positionTheta">0.00Â°</div>
        </div>
        <div class="status-item">
          <h4>å®šä½ç²¾åº¦</h4>
          <div class="value" id="localizationReliability">95%</div>
        </div>
      </div>
      
      <div class="navigation-controls">
        <button onclick="startAutoUpdate()">ğŸ”„ å¼€å§‹ç›‘æ§</button>
        <button onclick="stopAutoUpdate()">â¹ï¸ åœæ­¢ç›‘æ§</button>
        <button onclick="pauseNavigation()" id="pauseBtn">â¸ï¸ æš‚åœå¯¼èˆª</button>
        <button onclick="resumeNavigation()" id="resumeBtn">â–¶ï¸ æ¢å¤å¯¼èˆª</button>
        <button onclick="emergencyStop()">ğŸš¨ ç´§æ€¥åœæ­¢</button>
      </div>
      
      <div id="alertContainer"></div>
    </div>

    <!-- å¯¼èˆªæ§åˆ¶é¢æ¿ -->
    <div class="panel">
      <h3>ğŸ¯ å¯¼èˆªæ§åˆ¶</h3>
      
      <div class="input-group">
        <h4>è®¾ç½®å¯¼èˆªç›®æ ‡</h4>
        <label>Xåæ ‡:</label>
        <input type="number" id="goalX" step="0.1" value="5.0">
        <label>Yåæ ‡:</label>
        <input type="number" id="goalY" step="0.1" value="3.0">
        <label>è§’åº¦:</label>
        <input type="number" id="goalTheta" step="0.1" value="1.57">
        <button onclick="sendGoal()" style="margin-left: 10px;">ğŸš€ å‘é€ç›®æ ‡</button>
      </div>
      
      <div class="input-group">
        <h4>é€Ÿåº¦æ§åˆ¶</h4>
        <label>çº¿é€Ÿåº¦X:</label>
        <input type="number" id="velX" step="0.1" value="0.2">
        <label>çº¿é€Ÿåº¦Y:</label>
        <input type="number" id="velY" step="0.1" value="0.0">
        <label>è§’é€Ÿåº¦:</label>
        <input type="number" id="velTheta" step="0.1" value="0.1">
        <button onclick="sendCmdVel()" style="margin-left: 10px;">âš¡ å‘é€é€Ÿåº¦</button>
        <button onclick="stopMovement()">â¹ï¸ åœæ­¢ç§»åŠ¨</button>
      </div>
      
      <div class="input-group">
        <h4>ğŸ”” å·¡æ£€å›è°ƒæµ‹è¯•</h4>
        <label>æœºå™¨äººID:</label>
        <input type="number" id="callbackRobotId" value="1">
        <label>ä»»åŠ¡ID:</label>
        <input type="number" id="callbackTaskId" value="1001">
        <label>æ‰§è¡ŒçŠ¶æ€:</label>
        <select id="callbackStatus" style="margin-right: 10px;">
          <option value="SUCCEEDED">æˆåŠŸå®Œæˆ</option>
          <option value="FAILED">æ‰§è¡Œå¤±è´¥</option>
          <option value="success">æˆåŠŸ(å…¼å®¹)</option>
        </select>
        <button onclick="sendInspectionCallback('success')" style="margin-left: 10px;">âœ… æ¨¡æ‹ŸæˆåŠŸå›è°ƒ</button>
        <button onclick="sendInspectionCallback('failed')">âŒ æ¨¡æ‹Ÿå¤±è´¥å›è°ƒ</button>
      </div>
      
      <div id="goalRange" style="margin-top: 10px; color: #7f8c8d; font-size: 12px;"></div>
    </div>

    <!-- åœ°å›¾æ˜¾ç¤ºé¢æ¿ -->
    <div class="panel full-width">
      <h3>ğŸ—ºï¸ ç¯å¢ƒåœ°å›¾</h3>
      <div class="map-container">
        <canvas id="mapCanvas" width="1000" height="600"></canvas>
      </div>
    </div>

    <!-- çŠ¶æ€å†å²é¢æ¿ -->
    <div class="panel full-width">
      <h3>ğŸ“Š çŠ¶æ€å†å²è®°å½•</h3>
      <div class="history-log" id="historyLog">
        <div class="log-entry">
          <span class="log-timestamp">[ç³»ç»Ÿ]</span>
          <span>å¯¼èˆªç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨</span>
        </div>
      </div>
      <div style="margin-top: 10px;">
        <button onclick="clearHistory()">ğŸ—‘ï¸ æ¸…é™¤å†å²</button>
        <button onclick="exportHistory()">ğŸ“¥ å¯¼å‡ºæ—¥å¿—</button>
      </div>
    </div>
  </div>

  <script>
    let autoUpdateInterval = null;
    let mapData = null;
    let robotPose = {x: 0, y: 0, theta: 0};
    let navigationStatus = 'IDLE';
    let historyEntries = [];

    // çŠ¶æ€æ˜ å°„
    const statusConfig = {
      'IDLE': { class: 'status-idle', text: 'ç©ºé—²', color: '#95a5a6' },
      'GOING': { class: 'status-going', text: 'å¯¼èˆªä¸­', color: '#f39c12' },
      'PAUSED': { class: 'status-paused', text: 'å·²æš‚åœ', color: '#e67e22' },
      'SUCCEEDED': { class: 'status-succeeded', text: 'æˆåŠŸåˆ°è¾¾', color: '#27ae60' },
      'FAILED': { class: 'status-failed', text: 'å¯¼èˆªå¤±è´¥', color: '#e74c3c' }
    };

    function addHistoryEntry(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = {
        timestamp: timestamp,
        message: message,
        type: type
      };
      
      historyEntries.push(entry);
      
      const logDiv = document.getElementById('historyLog');
      const entryDiv = document.createElement('div');
      entryDiv.className = 'log-entry';
      entryDiv.innerHTML = `<span class="log-timestamp">[${timestamp}]</span><span>${message}</span>`;
      
      // æ ¹æ®ç±»å‹è®¾ç½®é¢œè‰²
      switch(type) {
        case 'success':
          entryDiv.style.color = '#2ecc71';
          break;
        case 'warning':
          entryDiv.style.color = '#f39c12';
          break;
        case 'error':
          entryDiv.style.color = '#e74c3c';
          break;
        default:
          entryDiv.style.color = '#ecf0f1';
      }
      
      logDiv.appendChild(entryDiv);
      logDiv.scrollTop = logDiv.scrollHeight;
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (historyEntries.length > 100) {
        historyEntries.shift();
        logDiv.removeChild(logDiv.firstChild);
      }
    }

    function showAlert(message, type = 'info') {
      const alertContainer = document.getElementById('alertContainer');
      const alertDiv = document.createElement('div');
      alertDiv.className = `alert alert-${type}`;
      alertDiv.textContent = message;
      
      alertContainer.appendChild(alertDiv);
      
      // 3ç§’åè‡ªåŠ¨ç§»é™¤
      setTimeout(() => {
        if (alertDiv.parentNode) {
          alertDiv.parentNode.removeChild(alertDiv);
        }
      }, 3000);
    }

    function updateNavigationStatus(status) {
      navigationStatus = status;
      const config = statusConfig[status] || statusConfig['IDLE'];
      
      document.getElementById('navigationStatus').textContent = config.text;
      const indicator = document.getElementById('statusIndicator');
      indicator.className = `status-indicator ${config.class}`;
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      const pauseBtn = document.getElementById('pauseBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      
      pauseBtn.disabled = (status !== 'GOING');
      resumeBtn.disabled = (status !== 'PAUSED');
      
      // è®°å½•çŠ¶æ€å˜åŒ–
      addHistoryEntry(`å¯¼èˆªçŠ¶æ€å˜æ›´ä¸º: ${config.text}`, 'info');
      
      // æ ¹æ®çŠ¶æ€æ˜¾ç¤ºæç¤º
      if (status === 'SUCCEEDED') {
        showAlert('ğŸ‰ å¯¼èˆªä»»åŠ¡æˆåŠŸå®Œæˆï¼', 'success');
      } else if (status === 'FAILED') {
        showAlert('âŒ å¯¼èˆªä»»åŠ¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›®æ ‡ç‚¹æˆ–ç¯å¢ƒ', 'error');
      }
    }

    function log(data) {
      // è°ƒè¯•æ—¥å¿—è¾“å‡ºåˆ°æ§åˆ¶å°
      console.log('Debug:', data);
    }

    function getMap() {
      fetch("http://localhost:8000/api/robot/map")
        .then(res => res.json())
        .then(data => {
          log(data);
          if (data.Result === 0) {
            mapData = data;
            drawMap(data);
            updateGoalRange();
            addHistoryEntry('åœ°å›¾æ•°æ®è·å–æˆåŠŸ', 'success');
          } else {
            console.error("è·å–åœ°å›¾å¤±è´¥:", data.Error);
            addHistoryEntry(`è·å–åœ°å›¾å¤±è´¥: ${data.Error}`, 'error');
          }
        })
        .catch(error => {
          console.error("è¯·æ±‚åœ°å›¾å¤±è´¥:", error);
          addHistoryEntry(`è¯·æ±‚åœ°å›¾å¤±è´¥: ${error.message}`, 'error');
        });
    }

    function getStatus() {
      fetch("http://localhost:8000/api/robot/status")
        .then(res => res.json())
        .then(data => {
          log(data);
          if (data.localization) {
            robotPose = {
              x: data.localization.x,
              y: data.localization.y,
              theta: data.localization.theta
            };
            
            // æ›´æ–°ä½ç½®æ˜¾ç¤º
            document.getElementById('positionX').textContent = robotPose.x.toFixed(2);
            document.getElementById('positionY').textContent = robotPose.y.toFixed(2);
            document.getElementById('positionTheta').textContent = robotPose.theta.toFixed(2) + 'Â°';
            
            // æ›´æ–°ç”µæ± æ˜¾ç¤º
            if (data.battery) {
              document.getElementById('batteryLevel').textContent = data.battery.power.toFixed(1) + '%';
              document.getElementById('batteryProgress').style.width = data.battery.power + '%';
            }
            
            // æ›´æ–°å®šä½ç²¾åº¦
            if (data.localization && data.localization.reliability) {
              document.getElementById('localizationReliability').textContent = 
                (data.localization.reliability * 100).toFixed(0) + '%';
            }
            
            if (mapData) {
              drawMap(mapData);
            }
          }
        })
        .catch(error => {
          console.error("è¯·æ±‚çŠ¶æ€å¤±è´¥:", error);
          addHistoryEntry(`è¯·æ±‚çŠ¶æ€å¤±è´¥: ${error.message}`, 'error');
        });
    }

    function getNavigationStatus() {
      fetch("http://localhost:8000/api/robot/navigation_status")
        .then(res => res.json())
        .then(data => {
          log(data);
          if (data.Result === 0) {
            updateNavigationStatus(data.status);
          } else {
            console.error("è·å–å¯¼èˆªçŠ¶æ€å¤±è´¥:", data.Error);
            addHistoryEntry(`è·å–å¯¼èˆªçŠ¶æ€å¤±è´¥: ${data.Error}`, 'error');
          }
        })
        .catch(error => {
          console.error("è¯·æ±‚å¯¼èˆªçŠ¶æ€å¤±è´¥:", error);
          addHistoryEntry(`è¯·æ±‚å¯¼èˆªçŠ¶æ€å¤±è´¥: ${error.message}`, 'error');
        });
    }

    function drawMap(mapInfo) {
      const canvas = document.getElementById("mapCanvas");
      if (!canvas) {
        console.error("åœ°å›¾ç”»å¸ƒå…ƒç´ ä¸å­˜åœ¨");
        return;
      }
      
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        console.error("æ— æ³•è·å–ç”»å¸ƒä¸Šä¸‹æ–‡");
        return;
      }
      
      console.log("å¼€å§‹ç»˜åˆ¶åœ°å›¾ï¼Œå°ºå¯¸:", mapInfo.width, "x", mapInfo.height);
      
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
      const scale = Math.min(canvas.width / mapInfo.width, canvas.height / mapInfo.height);
      const scaledWidth = mapInfo.width * scale;
      const scaledHeight = mapInfo.height * scale;
      const offsetX = (canvas.width - scaledWidth) / 2;
      const offsetY = (canvas.height - scaledHeight) / 2;
      
      // è§£æbase64æ•°æ®
      try {
        const binaryString = atob(mapInfo.data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        console.log("åœ°å›¾æ•°æ®è§£ææˆåŠŸï¼Œæ•°æ®é•¿åº¦:", bytes.length);
        
        // ç»˜åˆ¶æ …æ ¼åœ°å›¾
        for (let y = 0; y < mapInfo.height; y++) {
          for (let x = 0; x < mapInfo.width; x++) {
            const index = y * mapInfo.width + x;
            const value = bytes[index];
            
            let color;
            if (value === -1) {
              color = "#CCCCCC"; // æœªçŸ¥åŒºåŸŸ
            } else if (value === 0) {
              color = "#FFFFFF"; // ç©ºé—²åŒºåŸŸ
            } else if (value === 100) {
              color = "#000000"; // å ç”¨åŒºåŸŸ
            } else {
              const intensity = Math.floor(255 - (value * 2.55));
              color = `rgb(${intensity}, ${intensity}, ${intensity})`;
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(offsetX + x * scale, offsetY + y * scale, scale, scale);
          }
        }
        
        console.log("æ …æ ¼åœ°å›¾ç»˜åˆ¶å®Œæˆ");
        
        // ç»˜åˆ¶ç½‘æ ¼çº¿
        ctx.strokeStyle = "#E0E0E0";
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= mapInfo.width; x++) {
          ctx.beginPath();
          ctx.moveTo(offsetX + x * scale, offsetY);
          ctx.lineTo(offsetX + x * scale, offsetY + scaledHeight);
          ctx.stroke();
        }
        for (let y = 0; y <= mapInfo.height; y++) {
          ctx.beginPath();
          ctx.moveTo(offsetX, offsetY + y * scale);
          ctx.lineTo(offsetX + scaledWidth, offsetY + y * scale);
          ctx.stroke();
        }
        
        // ç»˜åˆ¶æœºå™¨äºº
        drawRobot(ctx, robotPose, offsetX, offsetY, scale, mapInfo);
        
        // æ˜¾ç¤ºåœ°å›¾ä¿¡æ¯
        ctx.fillStyle = "#333";
        ctx.font = "12px Arial";
        ctx.fillText(`åˆ†è¾¨ç‡: ${mapInfo.resolution}m`, 10, canvas.height - 40);
        ctx.fillText(`å°ºå¯¸: ${mapInfo.width}x${mapInfo.height}`, 10, canvas.height - 25);
        ctx.fillText(`åŸç‚¹: (${mapInfo.origin_x}, ${mapInfo.origin_y})`, 10, canvas.height - 10);
        
        console.log("åœ°å›¾ç»˜åˆ¶å®Œæˆ");
        
      } catch (error) {
        console.error("åœ°å›¾æ•°æ®è§£æå¤±è´¥:", error);
        addHistoryEntry(`åœ°å›¾æ•°æ®è§£æå¤±è´¥: ${error.message}`, 'error');
      }
    }

    function drawRobot(ctx, pose, offsetX, offsetY, scale, mapInfo) {
      const mapX = (pose.x - mapInfo.origin_x) / mapInfo.resolution;
      const mapY = (pose.y - mapInfo.origin_y) / mapInfo.resolution;
      const canvasX = offsetX + mapX * scale;
      const canvasY = offsetY + mapY * scale;
      
      ctx.save();
      ctx.translate(canvasX, canvasY);
      ctx.rotate(pose.theta);
      
      const size = Math.min(scale * 4, 20);
      
      // æ ¹æ®å¯¼èˆªçŠ¶æ€è®¾ç½®é¢œè‰²
      const config = statusConfig[navigationStatus] || statusConfig['IDLE'];
      ctx.fillStyle = config.color;
      ctx.strokeStyle = config.color;
      ctx.lineWidth = 3;
      
      ctx.beginPath();
      ctx.moveTo(size, 0);
      ctx.lineTo(-size/2, -size/2);
      ctx.lineTo(-size/2, size/2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      ctx.restore();
    }

    function updateGoalRange() {
      if (!mapData) return;
      
      const rangeDiv = document.getElementById("goalRange");
      const minX = mapData.origin_x;
      const maxX = mapData.origin_x + mapData.width * mapData.resolution;
      const minY = mapData.origin_y;
      const maxY = mapData.origin_y + mapData.height * mapData.resolution;
      
      rangeDiv.innerHTML = `ç›®æ ‡ç‚¹æœ‰æ•ˆèŒƒå›´: X[${minX.toFixed(1)}, ${maxX.toFixed(1)}], Y[${minY.toFixed(1)}, ${maxY.toFixed(1)}]`;
      
      document.getElementById("goalX").min = minX;
      document.getElementById("goalX").max = maxX;
      document.getElementById("goalY").min = minY;
      document.getElementById("goalY").max = maxY;
    }

    function sendGoal() {
      const goalX = parseFloat(document.getElementById("goalX").value);
      const goalY = parseFloat(document.getElementById("goalY").value);
      const goalTheta = parseFloat(document.getElementById("goalTheta").value);
      
      fetch("http://localhost:8000/api/robot/navigation_goal", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          goal_id: 1,
          goal_x: goalX,
          goal_y: goalY,
          goal_theta: goalTheta,
          xy_tolerance: 0.1,
          yaw_tolerance: 0.05
        })
      }).then(res => res.json())
        .then(data => {
          if (data.Result === 0) {
            addHistoryEntry(`å¯¼èˆªç›®æ ‡å·²å‘é€: X=${goalX}, Y=${goalY}, Î¸=${goalTheta}`, 'success');
            showAlert('ğŸ¯ å¯¼èˆªç›®æ ‡å·²å‘é€', 'success');
          } else {
            addHistoryEntry(`å¯¼èˆªç›®æ ‡å‘é€å¤±è´¥: ${data.Error}`, 'error');
            showAlert('âŒ å¯¼èˆªç›®æ ‡å‘é€å¤±è´¥', 'error');
          }
        });
    }

    function sendCmdVel() {
      const velX = parseFloat(document.getElementById("velX").value);
      const velY = parseFloat(document.getElementById("velY").value);
      const velTheta = parseFloat(document.getElementById("velTheta").value);
      
      fetch("http://localhost:8000/api/robot/cmd_vel", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          vel_x: velX,
          vel_y: velY,
          vel_theta: velTheta
        })
      }).then(res => res.json())
        .then(data => {
          if (data.Result === 0) {
            addHistoryEntry(`é€Ÿåº¦æŒ‡ä»¤å·²å‘é€: vx=${velX}, vy=${velY}, vÎ¸=${velTheta}`, 'success');
          } else {
            addHistoryEntry(`é€Ÿåº¦æŒ‡ä»¤å‘é€å¤±è´¥: ${data.Error}`, 'error');
          }
        });
    }

    function stopMovement() {
      fetch("http://localhost:8000/api/robot/cmd_vel", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          vel_x: 0.0,
          vel_y: 0.0,
          vel_theta: 0.0
        })
      }).then(res => res.json())
        .then(data => {
          if (data.Result === 0) {
            addHistoryEntry('æœºå™¨äººç§»åŠ¨å·²åœæ­¢', 'success');
            showAlert('â¹ï¸ æœºå™¨äººå·²åœæ­¢ç§»åŠ¨', 'warning');
          }
        });
    }

    function pauseNavigation() {
      fetch("http://localhost:8000/api/robot/pause_navigation", {
        method: "POST"
      }).then(res => res.json())
        .then(data => {
          if (data.Result === 0) {
            addHistoryEntry('å¯¼èˆªå·²æš‚åœ', 'warning');
            showAlert('â¸ï¸ å¯¼èˆªå·²æš‚åœ', 'warning');
          } else {
            addHistoryEntry(`æš‚åœå¯¼èˆªå¤±è´¥: ${data.Error}`, 'error');
          }
        });
    }

    function resumeNavigation() {
      fetch("http://localhost:8000/api/robot/resume_navigation", {
        method: "POST"
      }).then(res => res.json())
        .then(data => {
          if (data.Result === 0) {
            addHistoryEntry('å¯¼èˆªå·²æ¢å¤', 'success');
            showAlert('â–¶ï¸ å¯¼èˆªå·²æ¢å¤', 'success');
          } else {
            addHistoryEntry(`æ¢å¤å¯¼èˆªå¤±è´¥: ${data.Error}`, 'error');
          }
        });
    }

    function emergencyStop() {
      // åœæ­¢æ‰€æœ‰ç§»åŠ¨
      stopMovement();
      // æš‚åœå¯¼èˆª
      pauseNavigation();
      addHistoryEntry('ğŸš¨ ç´§æ€¥åœæ­¢å·²æ‰§è¡Œ', 'error');
      showAlert('ğŸš¨ ç´§æ€¥åœæ­¢å·²æ‰§è¡Œ', 'error');
    }

    function startAutoUpdate() {
      if (autoUpdateInterval) {
        clearInterval(autoUpdateInterval);
      }
      
      // ç«‹å³è·å–ä¸€æ¬¡æ•°æ®
      getMap();
      getStatus();
      getNavigationStatus();
      
      // æ¯ç§’æ›´æ–°ä¸€æ¬¡çŠ¶æ€ï¼Œæ¯5ç§’æ›´æ–°ä¸€æ¬¡åœ°å›¾
      let mapUpdateCounter = 0;
      autoUpdateInterval = setInterval(() => {
        getStatus();
        getNavigationStatus();
        mapUpdateCounter++;
        
        // æ¯5æ¬¡æ›´æ–°ä¸€æ¬¡åœ°å›¾ï¼ˆå‡å°‘åœ°å›¾æ›´æ–°é¢‘ç‡ï¼‰
        if (mapUpdateCounter >= 5) {
          getMap();
          mapUpdateCounter = 0;
        }
      }, 1000);
      
      addHistoryEntry('è‡ªåŠ¨ç›‘æ§å·²å¯åŠ¨', 'success');
      showAlert('ğŸ”„ è‡ªåŠ¨ç›‘æ§å·²å¯åŠ¨', 'success');
    }

    function stopAutoUpdate() {
      if (autoUpdateInterval) {
        clearInterval(autoUpdateInterval);
        autoUpdateInterval = null;
        addHistoryEntry('è‡ªåŠ¨ç›‘æ§å·²åœæ­¢', 'warning');
        showAlert('â¹ï¸ è‡ªåŠ¨ç›‘æ§å·²åœæ­¢', 'warning');
      }
    }

    function clearHistory() {
      historyEntries = [];
      const logDiv = document.getElementById('historyLog');
      logDiv.innerHTML = `
        <div class="log-entry">
          <span class="log-timestamp">[ç³»ç»Ÿ]</span>
          <span>å†å²è®°å½•å·²æ¸…é™¤</span>
        </div>
      `;
      addHistoryEntry('å†å²è®°å½•å·²æ¸…é™¤', 'info');
    }

    function exportHistory() {
      const dataStr = JSON.stringify(historyEntries, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `navigation_history_${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
      
      addHistoryEntry('å†å²è®°å½•å·²å¯¼å‡º', 'success');
    }

    // å·¡æ£€å›è°ƒé€šçŸ¥å‡½æ•°
    function sendInspectionCallback(statusType) {
      const robotId = document.getElementById('callbackRobotId').value;
      const taskId = document.getElementById('callbackTaskId').value;
      const statusSelect = document.getElementById('callbackStatus');
      
      // æ ¹æ®æŒ‰é’®ç±»å‹è®¾ç½®çŠ¶æ€
      if (statusType === 'success') {
        statusSelect.value = 'SUCCEEDED';
      } else if (statusType === 'failed') {
        statusSelect.value = 'FAILED';
      }
      
      const executionStatus = statusSelect.value;
      const executionTime = Date.now(); // è·å–å½“å‰æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
      
      const callbackData = {
        robot_id: parseInt(robotId),
        task_id: parseInt(taskId),
        execution_status: executionStatus,
        execution_time: executionTime
      };
      
      addHistoryEntry(`å‘é€å·¡æ£€å›è°ƒ: æœºå™¨äºº${robotId}, ä»»åŠ¡${taskId}, çŠ¶æ€${executionStatus}`, 'info');
      
      fetch("http://localhost:8000/api/inspection/callback", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(callbackData)
      }).then(res => res.json())
        .then(data => {
          if (data.code === 200) {
            addHistoryEntry(`å·¡æ£€å›è°ƒå‘é€æˆåŠŸ: ${data.msg}`, 'success');
            showAlert(`ğŸ”” å·¡æ£€å›è°ƒå‘é€æˆåŠŸ - ä»»åŠ¡${taskId}çŠ¶æ€: ${executionStatus}`, 'success');
            
            // å¦‚æœæ˜¯æ¨¡æ‹Ÿæ¨¡å¼ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åè·å–æœ€æ–°çš„å¯¼èˆªçŠ¶æ€
            setTimeout(() => {
              getNavigationStatus();
            }, 1000);
          } else {
            addHistoryEntry(`å·¡æ£€å›è°ƒå‘é€å¤±è´¥: ${data.msg}`, 'error');
            showAlert(`âŒ å·¡æ£€å›è°ƒå‘é€å¤±è´¥: ${data.msg}`, 'error');
          }
        })
        .catch(error => {
          console.error("å·¡æ£€å›è°ƒè¯·æ±‚å¤±è´¥:", error);
          addHistoryEntry(`å·¡æ£€å›è°ƒè¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
          showAlert(`âŒ å·¡æ£€å›è°ƒè¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
        });
    }

    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è·å–åœ°å›¾å’ŒçŠ¶æ€
    window.onload = function() {
      console.log("é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...");
      getMap();
      getStatus();
      getNavigationStatus();
      
      // è‡ªåŠ¨å¯åŠ¨ç›‘æ§
      setTimeout(startAutoUpdate, 1000);
    };
  </script>
</body>
</html>